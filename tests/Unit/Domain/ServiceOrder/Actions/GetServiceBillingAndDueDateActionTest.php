<?php

declare(strict_types=1);

use Domain\Service\Enums\BillingCycleEnum;
use Domain\ServiceOrder\Actions\GetServiceBillingAndDueDateAction;
use Domain\ServiceOrder\Database\Factories\ServiceBillFactory;
use Domain\ServiceOrder\Database\Factories\ServiceOrderFactory;
use Domain\ServiceOrder\Database\Factories\ServiceTransactionFactory;
use Domain\ServiceOrder\DataTransferObjects\GetServiceBillingAndDueData;
use Domain\ServiceOrder\Exceptions\AutoGeneratedBillNotAllowedException;
use Domain\ServiceOrder\Exceptions\NonSubscriptionNotAllowedException;
use Domain\ServiceOrder\Exceptions\ServiceBillStatusMusBePaidException;
use Domain\ServiceOrder\Exceptions\ServiceOrderStatusClosedNotAllowedException;
use Domain\ServiceOrder\Exceptions\ServiceTransactionStatusMusBePaidException;
use Illuminate\Support\Carbon;

beforeEach(function () {
    testInTenantContext();

    $this->dateFormat = 'Y-m-d';

    $this->getServiceBillingAndDueDateAction = app(GetServiceBillingAndDueDateAction::class);
});

$now = now();

$dataSets = [
    /** monthly billing cycle */
    [
        BillingCycleEnum::MONTHLY,  // billing cycle
        13,                         // current due date every
        $now->parse('2023-01-31'),  // ordered date
        $now->parse('2023-02-28'),  // current bill date
        $now->parse('2023-03-13'),  // current due date
        $now->parse('2023-03-28'),  // next bill date
        $now->parse('2023-04-10'),  // next due date
    ],
    [
        BillingCycleEnum::MONTHLY,  // billing cycle
        8,                          // current due date every
        $now->parse('2023-01-13'),  // ordered date
        $now->parse('2023-02-13'),  // current bill date
        $now->parse('2023-02-21'),  // current due date
        $now->parse('2023-03-13'),  // next bill date
        $now->parse('2023-03-21'),  // next due date
    ],
    [
        BillingCycleEnum::MONTHLY,  // billing cycle
        15,                         // current due date every
        $now->parse('2023-03-28'),  // ordered date
        $now->parse('2023-04-28'),  // current bill date
        $now->parse('2023-05-13'),  // current due date
        $now->parse('2023-05-28'),  // next bill date
        $now->parse('2023-06-12'),  // next due date
    ],
    /** yearly billing cycle */
    [
        BillingCycleEnum::YEARLY,   // billing cycle
        15,                         // current due date every
        $now->parse('2023-01-01'),  // ordered date
        $now->parse('2024-01-01'),  // current bill date
        $now->parse('2024-01-16'),  // current due date
        $now->parse('2025-01-01'),  // next bill date
        $now->parse('2025-01-16'),  // next due date
    ],
    [
        BillingCycleEnum::YEARLY,   // billing cycle
        16,                         // current due date every
        $now->parse('2024-02-29'),  // ordered date
        $now->parse('2025-02-28'),  // current bill date
        $now->parse('2025-03-16'),  // current due date
        $now->parse('2026-02-28'),  // next bill date
        $now->parse('2026-03-16'),  // next due date
    ],
];

it(
    'can get billing dates based on service transaction',
    function (
        BillingCycleEnum $billingCycle,
        int $dueDateEvery,
        Carbon $createdAt,
        Carbon $billDate,
        Carbon $dueDate,
        Carbon $nextBillDate,
        Carbon $nextDueDate
    ) {
        // set the current the curret date the day/s after the date ordered.
        now()->setTestNow(now()->parse($createdAt)->addDay());

        $serviceOrder = ServiceOrderFactory::new()
            ->active()
            ->subscriptionBased()
            ->nonAutoGeneratedBills()
            ->has(
                ServiceBillFactory::new()
                    ->billingDate(null)
                    ->dueDate(null)
                    ->paid()
                    ->has(ServiceTransactionFactory::new())
            )
            ->createOne([
                'billing_cycle' => $billingCycle,
                'due_date_every' => $dueDateEvery,
            ]);

        $serviceBill = $serviceOrder->latestServiceBill();

        $dates = $this->getServiceBillingAndDueDateAction
            ->execute(
                new GetServiceBillingAndDueData(
                    service_order: $serviceOrder,
                    service_bill: $serviceBill,
                    service_transaction: $serviceBill->serviceTransactions->first()
                )
            );

        expect($dates->bill_date)
            ->toBeGreaterThan($nextBillDate);

        expect($dates->due_date)
            ->toBeGreaterThan($dates->bill_date);
    }
)->with($dataSets);

it(
    'can get billing dates based on service bill (on-time payment)',
    function (
        BillingCycleEnum $billingCycle,
        int $dueDateEvery,
        Carbon $createdAt,
        Carbon $billDate,
        Carbon $dueDate,
        Carbon $nextBillDate,
        Carbon $nextDueDate
    ) {
        // set current date before the bill's due date.
        now()->setTestNow(now()->parse($dueDate)->subDay());

        $serviceOrder = ServiceOrderFactory::new()
            ->active()
            ->subscriptionBased()
            ->nonAutoGeneratedBills()
            ->has(
                ServiceBillFactory::new()
                    ->billingDate($billDate)
                    ->dueDate($dueDate)
                    ->paid()
                    ->has(ServiceTransactionFactory::new())
            )
            ->createOne([
                'billing_cycle' => $billingCycle,
                'due_date_every' => $dueDateEvery,
            ]);

        $serviceBill = $serviceOrder->serviceBills->first();

        $dates = $this->getServiceBillingAndDueDateAction
            ->execute(
                new GetServiceBillingAndDueData(
                    service_order: $serviceOrder,
                    service_bill: $serviceBill,
                    service_transaction: $serviceBill->serviceTransactions->first()
                )
            );

        expect(
            $dates->bill_date
                ->format($this->dateFormat)
        )
            ->toBe($nextBillDate->format($this->dateFormat));

        expect(
            $dates->due_date
                ->format($this->dateFormat)
        )
            ->toBe($nextDueDate->format($this->dateFormat));
    }
)->with($dataSets);

it(
    'can get billing dates based on service bill (late payment)',
    function (
        BillingCycleEnum $billingCycle,
        int $dueDateEvery,
        Carbon $createdAt,
        Carbon $billDate,
        Carbon $dueDate,
        Carbon $nextBillDate,
        Carbon $nextDueDate
    ) {
        // set current date after the bill's due date.
        now()->setTestNow(now()->parse($dueDate)->addDay());

        $serviceOrder = ServiceOrderFactory::new()
            ->active()
            ->subscriptionBased()
            ->nonAutoGeneratedBills()
            ->has(
                ServiceBillFactory::new()
                    ->billingDate($billDate)
                    ->dueDate($dueDate)
                    ->paid()
                    ->has(ServiceTransactionFactory::new())
            )
            ->createOne([
                'billing_cycle' => $billingCycle,
                'due_date_every' => $dueDateEvery,
            ]);

        $serviceBill = $serviceOrder->serviceBills->first();

        $dates = $this->getServiceBillingAndDueDateAction
            ->execute(
                new GetServiceBillingAndDueData(
                    service_order: $serviceOrder,
                    service_bill: $serviceBill,
                    service_transaction: $serviceBill->serviceTransactions->first()
                )
            );

        expect($dates->bill_date)
            ->toBeGreaterThan($nextBillDate);

        expect($dates->due_date)
            ->toBeGreaterThan($dates->bill_date);
    }
)->with($dataSets);

it('can get billing dates (daily billing cycle)', function () {
    $serviceOrder = ServiceOrderFactory::new()
        ->active()
        ->subscriptionBased()
        ->nonAutoGeneratedBills()
        ->has(
            ServiceBillFactory::new()
                ->billingDate(null)
                ->dueDate(null)
                ->has(ServiceTransactionFactory::new())
                ->paid()
        )
        ->dailyBillingCycle()
        ->createOne();

    $serviceBill = $serviceOrder->serviceBills
        ->first();

    $dates = $this->getServiceBillingAndDueDateAction
        ->execute(
            new GetServiceBillingAndDueData(
                service_order: $serviceOrder,
                service_bill: $serviceBill,
                service_transaction: $serviceBill->serviceTransactions->first()
            )
        );

    expect($dates->bill_date)
        ->toBeGreaterThan(
            $serviceOrder->latestServiceBill()
                ->serviceTransactions
                ->first()
                ->created_at
        );

    expect($dates->due_date)
        ->toEqual($dates->bill_date);
});

it('cannot execute on non subscription based service', function () {
    $serviceOrder = ServiceOrderFactory::new()
        ->active()
        ->nonSubscriptionBased()
        ->has(
            ServiceBillFactory::new()
                ->has(ServiceTransactionFactory::new())
                ->paid()
        )
        ->monthlyBillingCycle()
        ->createOne();

    $serviceBill = $serviceOrder->serviceBills
        ->first();

    $this->getServiceBillingAndDueDateAction
        ->execute(
            new GetServiceBillingAndDueData(
                service_order: $serviceOrder,
                service_bill: $serviceBill,
                service_transaction: $serviceBill->serviceTransactions->first()
            )
        );
})
    ->throws(NonSubscriptionNotAllowedException::class);

it('cannot execute on auto generated bills service', function () {
    $serviceOrder = ServiceOrderFactory::new()
        ->active()
        ->subscriptionBased()
        ->autoGeneratedBills()
        ->has(
            ServiceBillFactory::new()
                ->has(ServiceTransactionFactory::new())
                ->paid()
        )
        ->monthlyBillingCycle()
        ->createOne();

    $serviceBill = $serviceOrder->serviceBills
        ->first();

    $this->getServiceBillingAndDueDateAction
        ->execute(
            new GetServiceBillingAndDueData(
                service_order: $serviceOrder,
                service_bill: $serviceBill,
                service_transaction: $serviceBill->serviceTransactions->first()
            )
        );
})
    ->throws(AutoGeneratedBillNotAllowedException::class);

it('cannot execute on unpaid service bill status', function () {
    $serviceOrder = ServiceOrderFactory::new()
        ->active()
        ->subscriptionBased()
        ->nonAutoGeneratedBills()
        ->has(
            ServiceBillFactory::new()
                ->has(ServiceTransactionFactory::new())
                ->pending()
        )
        ->monthlyBillingCycle()
        ->createOne();

    $serviceBill = $serviceOrder->serviceBills
        ->first();

    $this->getServiceBillingAndDueDateAction
        ->execute(
            new GetServiceBillingAndDueData(
                service_order: $serviceOrder,
                service_bill: $serviceBill,
                service_transaction: $serviceBill->serviceTransactions->first()
            )
        );
})
    ->throws(ServiceBillStatusMusBePaidException::class);

it('cannot execute on unpaid service transaction status', function () {
    $serviceOrder = ServiceOrderFactory::new()
        ->active()
        ->subscriptionBased()
        ->nonAutoGeneratedBills()
        ->has(
            ServiceBillFactory::new()
                ->has(ServiceTransactionFactory::new()->pending())
                ->paid()
        )
        ->monthlyBillingCycle()
        ->createOne();

    $serviceBill = $serviceOrder->serviceBills
        ->first();

    $this->getServiceBillingAndDueDateAction
        ->execute(
            new GetServiceBillingAndDueData(
                service_order: $serviceOrder,
                service_bill: $serviceBill,
                service_transaction: $serviceBill->serviceTransactions->first()
            )
        );
})
    ->throws(ServiceTransactionStatusMusBePaidException::class);

it('cannot execute on inactive service order status', function () {
    $serviceOrder = ServiceOrderFactory::new()
        ->closed()
        ->subscriptionBased()
        ->nonAutoGeneratedBills()
        ->has(
            ServiceBillFactory::new()
                ->has(ServiceTransactionFactory::new())
                ->paid()
        )
        ->yearlyBillingCycle()
        ->createOne();

    $serviceBill = $serviceOrder->serviceBills
        ->first();

    $this->getServiceBillingAndDueDateAction
        ->execute(
            new GetServiceBillingAndDueData(
                service_order: $serviceOrder,
                service_bill: $serviceBill,
                service_transaction: $serviceBill->serviceTransactions->first()
            )
        );
})
    ->throws(ServiceOrderStatusClosedNotAllowedException::class);
