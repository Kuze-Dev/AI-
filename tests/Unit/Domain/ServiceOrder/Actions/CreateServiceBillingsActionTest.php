<?php

declare(strict_types=1);

use Domain\Customer\Database\Factories\CustomerFactory;
use Domain\ServiceOrder\Actions\CreateServiceBillingsAction;
use Domain\ServiceOrder\Database\Factories\ServiceBillFactory;
use Domain\ServiceOrder\Database\Factories\ServiceOrderFactory;
use Domain\ServiceOrder\Database\Factories\ServiceTransactionFactory;
use Domain\ServiceOrder\Jobs\CreateServiceBillJob;
use Domain\ServiceOrder\Models\ServiceTransaction;
use Illuminate\Support\Facades\Queue;

beforeEach(function () {
    testInTenantContext();

    Queue::fake();
});

it('can dispatch billable customer only', function () {
    CustomerFactory::new()
        ->active()
        ->registered()
        ->has(
            ServiceOrderFactory::new()
                ->active()
                ->autoGeneratedBills()
                ->subscriptionBased()
                ->has(
                    ServiceBillFactory::new()
                        ->paid()
                )
        )
        ->createOne();

    app(CreateServiceBillingsAction::class)->execute();

    Queue::assertPushed(CreateServiceBillJob::class);
});

it('cannot dispatch non subscription service order', function () {
    CustomerFactory::new()
        ->active()
        ->registered()
        ->has(
            ServiceOrderFactory::new()
                ->active()
                ->nonSubscriptionBased()
                ->autoGeneratedBills()
                ->has(
                    ServiceBillFactory::new()
                        ->paid()
                )
        )
        ->createOne();

    app(CreateServiceBillingsAction::class)->execute();

    Queue::assertNotPushed(CreateServiceBillJob::class);
});

it('cannot dispatch active only customer', function () {
    CustomerFactory::new()
        ->active()
        ->unregistered()
        ->createOne();

    app(CreateServiceBillingsAction::class)->execute();

    Queue::assertNotPushed(CreateServiceBillJob::class);
});

it('cannot dispatch registered only customer', function () {
    CustomerFactory::new()
        ->inactive()
        ->registered()
        ->createOne();

    app(CreateServiceBillingsAction::class)->execute();

    Queue::assertNotPushed(CreateServiceBillJob::class);
});

it('cannot dispatch closed service order', function () {
    CustomerFactory::new()
        ->active()
        ->registered()
        ->has(
            ServiceOrderFactory::new()
                ->autoGeneratedBills()
                ->subscriptionBased()
                ->closed()
                ->has(
                    ServiceBillFactory::new()
                        ->paid()
                )
        )
        ->createOne();

    app(CreateServiceBillingsAction::class)->execute();

    Queue::assertNotPushed(CreateServiceBillJob::class);
});

it('cannot dispatch active service order without current/latest bill', function () {
    CustomerFactory::new()
        ->active()
        ->registered()
        ->has(
            ServiceOrderFactory::new()
                ->autoGeneratedBills()
                ->subscriptionBased()
                ->active()
        )
        ->createOne();

    app(CreateServiceBillingsAction::class)->execute();

    Queue::assertNotPushed(CreateServiceBillJob::class);
});

it('cannot dispatch on non auto generated bills', function () {
    CustomerFactory::new()
        ->active()
        ->registered()
        ->has(
            ServiceOrderFactory::new()
                ->nonAutoGeneratedBills()
                ->subscriptionBased()
                ->active()
                ->has(
                    ServiceBillFactory::new()
                        ->paid()
                )
        )
        ->createOne();

    app(CreateServiceBillingsAction::class)->execute();

    Queue::assertNotPushed(CreateServiceBillJob::class);
});

it('can dispatch based on service transaction', function () {
    CustomerFactory::new()
        ->active()
        ->registered()
        ->has(
            ServiceOrderFactory::new()
                ->active()
                ->autoGeneratedBills()
                ->subscriptionBased()
                ->monthlyBillingCycle()
                ->has(
                    ServiceBillFactory::new()
                        ->billingDate(null)
                        ->dueDate(null)
                        ->has(ServiceTransactionFactory::new())
                        ->paid()
                )
        )
        ->createOne();

    now()->setTestNow(
        ServiceTransaction::first()
            ->created_at
            ->addMonthNoOverflow()
            ->toDateString()
    );

    app(CreateServiceBillingsAction::class)->execute();

    Queue::assertPushed(CreateServiceBillJob::class);
});

it('can dispatch on unpaid (pending) latest/current bill', function () {
    CustomerFactory::new()
        ->active()
        ->registered()
        ->has(
            ServiceOrderFactory::new()
                ->active()
                ->autoGeneratedBills()
                ->subscriptionBased()
                ->monthlyBillingCycle()
                ->has(
                    ServiceBillFactory::new()
                        ->pending()
                )
        )
        ->createOne();

    app(CreateServiceBillingsAction::class)->execute();

    Queue::assertPushed(CreateServiceBillJob::class);
});

it('can dispatch on paid initial bill', function () {
    CustomerFactory::new()
        ->active()
        ->registered()
        ->has(
            ServiceOrderFactory::new()
                ->active()
                ->autoGeneratedBills()
                ->subscriptionBased()
                ->monthlyBillingCycle()
                ->has(
                    ServiceBillFactory::new()
                        ->billingDate(null)
                        ->dueDate(null)
                        ->paid()
                        ->has(ServiceTransactionFactory::new())
                )
        )
        ->createOne();

    now()->setTestNow(
        ServiceTransaction::first()
            ->created_at
            ->addMonthNoOverflow()
            ->toDateString()
    );

    app(CreateServiceBillingsAction::class)->execute();

    Queue::assertPushed(CreateServiceBillJob::class);
});

it('cannot dispatch on unpaid (pending) initial bill', function () {
    CustomerFactory::new()
        ->active()
        ->registered()
        ->has(
            ServiceOrderFactory::new()
                ->active()
                ->autoGeneratedBills()
                ->subscriptionBased()
                ->monthlyBillingCycle()
                ->has(
                    ServiceBillFactory::new()
                        ->billingDate(null)
                        ->dueDate(null)
                        ->pending()
                )
        )
        ->createOne();

    app(CreateServiceBillingsAction::class)->execute();

    Queue::assertNotPushed(CreateServiceBillJob::class);
});

it('can dispatch on multiple transactions', function () {
    CustomerFactory::new()
        ->active()
        ->registered()
        ->has(
            ServiceOrderFactory::new()
                ->active()
                ->autoGeneratedBills()
                ->subscriptionBased()
                ->monthlyBillingCycle()
                ->has(
                    ServiceBillFactory::new()
                        ->billingDate(null)
                        ->dueDate(null)
                        ->paid()
                        ->has(ServiceTransactionFactory::new())
                        ->has(ServiceTransactionFactory::new()->pending())
                )
        )
        ->createOne();

    now()->setTestNow(
        ServiceTransaction::first()
            ->created_at
            ->addMonthNoOverflow()
            ->toDateString()
    );

    app(CreateServiceBillingsAction::class)->execute();

    Queue::assertPushed(CreateServiceBillJob::class);
});
